---
title: "Sick Sicker Simmer Constrained (Part 2)"
author: "Shawn Garbett, John Graves"
format: html
editor: source
---

## Goal

Sick/Sicker with resource constraints in DES.

A continuation of [Part 1](http://htmlpreview.github.io/?https://github.com/spgarbet/sick_sicker_des/master/Sick_Sicker_Simmer_DES.html).

The Sick/Simmer model constructed previously did not use the full power of
what discrete event simulation has to offer. This will build on the previous
work and include a demonstration of the effects of a resource constraint.

> *"Art in nature is rhythmic and has a horror of constraints."* --Robert Delaunay

### Technical Details

One thing to be aware of is that if one were to execute each patient trajectory
as a simulation outside of a discrete event simulation (DES) framework it would
likely have much higher performance. A DES framework has to execute all trajectories
at the same time, evaluate them all to check for any resource contention and this
penalty is fixed whether or not the model has resource constraints. A large
number of cost effectiveness studies utilizing DES do not have constrained
resources. To put the problem in perspective, independent simulations are
$\mathcal{O}(n)$ in complexity of execution. Meaning the total time/memory
utilization is proportional to the number of individuals simulated. DES
requires the fixed cost of resource contention checking, and has to manage this
utilizing a heap and this makes the complexity $\mathcal{O}(n \log n)$. This is
a theoretical limitation based on complexity.

In earlier unpublished [work](https://github.com/spgarbet/sick_sicker_des) we^[Shawn Garbett, Fernando Alarid-Escudero, Cole Beck] quantified the differences using a Sick Sicker model.

![](des_versus_dt.png)

This shows that in a practical case, when $N >= 100,000$ the 
simmer based DES solution because impractical. For our in house
models using simmer we batched them into units of 100,000 
patients and ran using the method outlined in our
[ACCRE](https://github.com/vubiostat/accre_tutorial) tutorial.

If one needs a full DES due to resource constraints, this problem is not
easily avoidable--and the $N$ of single DES simulation becomes the number contending
for a finite resource.

A general review of [Queueing Systems](https://r-simmer.org/articles/simmer-06-queueing) 
in simmer is helpful. 

## Modified Problem Statement

What if there were resource constraints (e.g. facilities) to get patients 
inducted onto medication and the process took time? We are doing to split 
the state of "Sick 1" or S1 into S1U "Sick 1 Untreated" and "Sick 1 Treated"
and introduce treatment induction resource constraint, sometimes called 
a "tunnel state". In this case there is a queue to enter the tunnel. 

The focus of the model now shifts from comparing treatment to no treatment, to 
doing a profile of the impact of investment on reduction of waiting. 

## A NaÃ¯ve Solution

We copy `inputs.R` to `inputs2.R` and `model-7.R` to `model-8.R`
_Please note, in practice renaming files like
this should not be done and one would use git to track versions of a file like
inputs, but for pedantic purposes we have all versions available in a flat 
archive_ and make the following edits to inputs2.R


```
    strategy = 'notreat',# Default strategy is no treatment
    
    # Resource Constraint
    n.capacity = 2       # Number of individuals who can receive treatment
```

Further, we bumped the N value to 20. 

We intend to severely limit the capacity of treatment to Sick individuals. 

Further remove `"sick"` from the counter list in `model-7.R` and add

```
add_resource("treat", inputs$n.capacity) |>
```

to the `des_run` function.

This means that the resource `treat` has a capacity to treat 2 patients at a
time, and has infinite waiting room capacity. This will cause the `event_sick`
function call to `seize("treat)` to pause if 2 patients are already
receiving treatment. 

The `sick1` event handling function is also overridden locally to show how
long a patient spent waiting.

```{r sim8}
source("model-8.R")

x = des_run(inputs)
```

This debug output demonstrates that 20 patients with a single treament center
that can handle 2 individuals-- the resources constraint is having an effect
on patient outcomes--as they are forced to wait years for treatment (years being
the unit of simulation time in this example).

Let's check on Death rates. 

```{r sim8_2}
source("model-8.R")
inputs$N <- 100
dr.constrained <- replicate(100,
{
  capture.output(x <- des_run(inputs), file=nullfile())
  sum(x$resource == 'death')
})

```

What did it look like before our changes?

```{r sim7_1}
source("model-7.R")
inputs$N <- 100
dr.original <- replicate(100,
{
  capture.output(x <- des_run(inputs), file=nullfile())
  sum(x$resource == 'death')
})
t.test(dr.constrained, dr.original)
```

First of all note we had to run replicates of the simulation to determine
effect size. Secondly, the t-test comparison between the runs shows
a statistically discernable difference. 

While we have implemented a resource constraint, the face validity of the model
is broken as a patient awaiting treatment 
can no longer progress back to Healthy, Sick2 or Death until treatment is
received This has prevented a lot of simulated deaths, but only
by destroying the simulated rate of death.

A strategy to let the original simulation proceed is required.

## Clone and Synchronize

Fortunately, `simmer` has tools to help deal with this. In this case it's 
not as straightforward as we've already built a tool chain that doesn't
account for resource constraints. We need to use the `clone` and `synchronize`
operators and do so without disturbing the original event loop.

`clone` will split a trajectory, and attributes and resources are inherited.
`synchronize` throws away all but one trajectory that reaches it. 

The strategy is to clone the trajectory and let one escape back into our
simulation engine, while the other seizes the treatment resource. This leads
to the conundrum that the main loop needs to know about treatment and 
should be able to release it. 

Asynchronous coding is very difficult, but we're going to have to cross that
bridge. To do this, one of the split threads will seize and release the
treatment resource with limited access but it will rely on passing signals back
and forth with it's sibling trajectory. `signal` and `trap` allow this to happen.
The inverse trap is required to get a signal back to tell it to release the
treatment and cleanup. 




```{r sim9_1}
source("model-9.R")
inputs$N <- 100
dr.constrained <- replicate(100,
{
  capture.output(x <- des_run(inputs), file=nullfile())
  sum(x$resource == 'death')
})
t.test(dr.constrained, dr.original)
```

The death rate is still different, but in this case the deaths go up which 
is in line with what we expected by restricting treatment. A good sign 
that our modifications are working as intended.

