---
title: "2. Progressive Disease Model"
subtitle: "Discrete Event Simulation for Health Decision Modeling"
author: 
  - name: "John Graves"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt Owen Gradute School of Management"
      - "Vanderbilt University Medical Center"
    email: "john.graves@vanderbilt.edu"
  - name: "Shawn Garbett"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt University Medical Center"    
    email: "shawn.garbett@vumc.org"
date: today
format: 
  closeread-html:
    css: des-styling.css
    code-tools: false
    fig-format: svg
    toc: false
    linkcolor: tomato
bibliography: references.bib    
editor_options: 
  chunk_output_type: console
---


```{r setup}
#| echo: false
#| warning: false
#| message: false

library(simmer)
library(here)

source(here('inputs.R'))     # Model Parameters
source(here('main_loop.R'))  # Helper functions
source(here('discount.R'))   # Discounting functions
```

# Model 1


:::{.cr-section layout="overlay-center"}


For our first (very simple!) DES we will model a system that initiates in a healthy state ... [@cr-petri1]{pan-to="50%,50%" scale-by="2"}

[@cr-petri1]{pan-to="50%,-50%" scale-by="2"}  ... and then follows patients for a defined 30-year time horizon. 

[@cr-petri1]{pan-to="-50%,-50%" scale-by="1"} 

@cr-petri1

Later, we will build up this very simple DES by incorporating additional components such as health state transitions, background mortality, and resource queues. 

:::{#cr-petri1}
![](images/petri-model1.png){fig-align="center"}
:::

:::


## Counters

::: {.column-screen style="background-image:url(images/scoreboard-race.png); background-size: 100vw; height: 600px; background-position: center -55%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>



Think of a counter like a scoreboard that lists race times, including times for each lap (event) in the race. For our simple model, our counter will operate exactly like this---it will simply track the amount of time each patient spends in the model. 



:::{.cr-section}

Counters are defined as a vector object that provides the names of each event we want to track in the model. This vector will be used later with a convenience function we have written for `Simmer` ( `main_loop()`) to define resources with infinite capacity, i.e., there is no competition for a resource like "time in model"). @cr-counters0

For this very simple model, we will simply track patients for a defined time horizon of 30 years.  Thus, our first `counter` will be `time_in_model`. @cr-counters

:::{#cr-counters0}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

counters <- c(
  #<names of counters go here>
)
```
:::

:::{#cr-counters}
```{r}
#| echo: true
#| code-line-numbers: false

counters <- c(
  "time_in_model"
)
```

:::
:::


## Initializing Patients

We next need to define a process that will initialize patients in the model. Extending the racing analogy further, think of this process in terms of defining the pole positions of each "car" in the race: we want to define baseline attributes, like:

- Age
- Disease status (e.g., healthy, ill)
- Gender


::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 500px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>


:::{.cr-section layout="overlay-center"}

The pipe operator |> in R is a tool for chaining operations together in a left-to-right, readable sequence. Instead of nesting functions or creating intermediate variables, you "pipe" the output of one function directly into the next function as its first argument.

:::

:::{.cr-section layout="sidebar-right"}
For example, this syntax using pipe operators ... 
@cr-pipesyntax

:::{#cr-pipesyntax}
```{r}
#| echo: true
#| eval: false

data |> function1() |> function2() |> function3()
```
:::
:::


:::{.cr-section layout="sidebar-right"}

@cr-pipesyntax2  
... is equivalent to:
@cr-pipesyntax2

:::{#cr-pipesyntax2}
```{r}
#| echo: true
#| eval: false

function3(function2(function1(data)))
```

:::
:::

Let's now define a function `initialize_patient()` to define the starting state of a patient. This can be as complex as needed to define the attributes of the starting population of a study.

::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 500px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.25"}
:::



:::{.cr-section }
Our function has two inputs: `traj` and `inputs`. [@cr-initialize]{highlight="1"}  The object `inputs` are the parameters that define our model, and were defined above (and are also stored in `inputs.R`). 

A trajectory (`traj`) is a sequence of events that defines what happens to people as they move through the DES. You can think of `traj` in terms of a personalized race course for each person in the model. 

In our code here, for a given patient we start with its trajectory [@cr-initialize]{highlight="3"}

We then feed this trajectory into the simmer function `seize()`. [@cr-initialize]{highlight="4"} This function siezes the counter `time_in_model`  that we defined above. You can think of this step in terms of taking our patient and directing them to the starting line of the simulation.   

The `initialize_patient()` function is also our opportunity to set baseline attributes of our patients. For example, here we sample the patient's age in years from a uniform distribution between age 20 and 30. [@cr-initialize]{highlight="5"} This attribute isn't actually going to be used for now; we include it here simply to demonstrate how baseline attributes can be set. You can define as many of these attributes as needed to execute the model. 


@cr-initialize


:::{#cr-initialize}
```{r}
#| echo: true
#| code-line-numbers: true
initialize_patient <- function(traj, inputs)
{
  traj                   |>
  seize("time_in_model") |>
  set_attribute("AgeInitial", function() sample(20:30, 1))
}
```
:::


:::

:::{.cr-section layout="overlay-center"}
**NOTE**: It is important when using simmer to mostly pass functions for defining things in a trajectory. This is a call back, and if not done properly it can result in puzzling behavior. If one passed to simmer the following: `sample(20:30,1)`, it would result in a single random draw applied to every single patient. For example, if 25 were draw every patient would be 25. Instead one needs to pass to simmer `function() sample(20:30,1)` to get a random draw for each patient resulting a uniform spread of this parameter. If every patient had the same attribute being assigned, it would be fine to leave off the `function()`, but this can lead to forgetting to do it in cases where it's needed and it doesn't hurt to leave it in on all calls. @cr-initialize
:::


## Define the Finish Line

The steps above were used to define the starting line and to define the dimensions we want to track and measure. The last step is to define where the model should end. That is, how do we define the "end" of the patient's trajectory through the system? Once we define this end, we need to "release" the various counters (e.g., time in model) and resources we've defined. 

We'll do this using a series of "cleanup" functions that release the patient at the end of their journey through the model. 

::: {.column-screen style="background-image:url(images/finish-line-cars.png); background-size: 100vw; height: 300px; background-position: center 35%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

:::{.cr-section}

When a patient leaves the simulation via any means it is helpful to have a function that examines the state or attributes of that patient/trajectory and releases any resources they used. @cr-cleanup

[@cr-cleanup]{highlight="1-5"} In this section, we know they've seized `time_in_model`, so they need to let that go when they exit.

This function can get a lot more complex as patient state grows more complex.


[@cr-cleanup]{highlight="7-14"} This routine terminates the trajectory and calls the above cleanup. These two pieces could easily have been one function, but keeping them separate has proven useful in practice, primarily for organizational purposes.


:::{#cr-cleanup}
```{r}
#| echo: true
#| code-line-numbers: true

cleanup_on_termination <- function(traj)
{
  traj |> 
  release("time_in_model")
}

terminate_simulation <- function(traj, inputs)
{
  traj |>
  branch( function() 1, 
          continue=FALSE,
          trajectory() |> cleanup_on_termination()
        )
}

```

:::
:::

## Event Registry

Now we're approaching the heart of the model. The event registry. We're going to define a single event to terminate the patient trajectory when the defined time horizon is reached. For a full life simulation such a function isn't needed as a proper mortality model would have individuals simulated die at some point, however it's not bad to have something like this to prevent a run away simulation.


:::{.cr-section}

Here's how it looks for a single entry. @cr-registry

:::{#cr-registry}
```{r}
#| echo: true
#| code-line-numbers: true

event_registry <- list(
  list(name          = "Terminate at time horizon",
       attr          = "aTerminate",
       time_to_event = function(inputs) inputs$horizon,
       func          = terminate_simulation,
       reactive      = FALSE)
)
```
:::

[@cr-registry]{highlight="2"} The `name` field is for debugging purposes and may come up on a simmer trace. It's not used much in practice. 

[@cr-registry]{highlight="3"} `attr` is the name of the attribute on a patient used to store the time to event. It needs to be unique and not correspond to any other attribute name defined on the patient. 

[@cr-registry]{highlight="4"} `time_to_event` is a callback function that defines how long till the event occurs. Simulation time starts at 0 and proceeds forward. 

[@cr-registry]{highlight="4"}  In this model we have chosen the cycle to each a year. Thus when time reaches 2.0, that's 2 years into the simulation for that patient---*not their age*. 

[@cr-registry]{highlight="5"} The `func` is the callback function that will modify the state of the patient, in this case it's the terminate simulation function defined above.

[@cr-registry]{highlight="6"}  The `reactive` field is a logical TRUE/FALSE that defines whether all other events should be redraw if this event fires. In this case the patient trajectory is ending, so no events for them should be redrawn.

:::

## Tracking Outcomes 

### Quality of Life (QoL)

:::{.cr-section }

@cr-QoL

:::{#cr-QoL}

```{r}
#| echo: true
#| code-line-numbers: true

qaly_arrivals <- function(arrivals, inputs)
{
  arrivals$qaly  <- 0  # No qaly yet
  arrivals$dqaly <- 0  # No discounted qaly either
  
  selector <- arrivals$resource == 'time_in_model'
  arrivals$qaly[selector] <-
    arrivals$end_time[selector] - 
    arrivals$start_time[selector]
  arrivals$dqaly[selector] <- 
      discount_value(1, 
                     arrivals$start_time[selector],
                     arrivals$end_time[selector])
    
  arrivals
}

```
:::
:::



### Costs

We need to define incured costs for our model. It should take the data.frame from `des_run` and add cost columns for the resources. We pass in the inputs as they might be needed. We will ignore the costs for healthy till we can add that state later.

:::{.cr-section}

@cr-costs

:::{#cr-costs}

```{r}
#| echo: true
#| code-line-numbers: true
cost_arrivals <- function(arrivals, inputs)
{
  arrivals$cost  <- 0  # No costs yet
  arrivals$dcost <- 0  # No discounted costs either
  
  arrivals
}
```

:::
:::




:::{.cr-section}

The function `des_run` is the primary simulation function. @cr-desrun1

[@cr-desrun1]{highlight="3"} The first step is to create a global environment used to run simmer. This is followed by creating a des definition of a trajectory (this function is in `main_loop`. It uses the things we've defined above.

[@cr-desrun1]{highlight="4"}  The patient trajectory (`traj`) is defined by our helper function `des()`, which can be found in `main_loop.R`. It essentially creates a patient, assigns attributes and events, and processes the events. Think of this function as the one that runs a single car through the race course. 

[@cr-desrun1]{highlight="5-10"}   `env` is given resources or counters, patients are generated into the simulation, the simulation is run for an amount of time (just past the horizon) and then the `wrap` makes sure all summaries are ready.

[@cr-desrun1]{highlight="12"} `get_mon_arrival` returns us the trajectories of the patients in a `data.frame`. We will expand on this quite a bit later. It really the soul of understanding what's going on in a simulation and critical for auditing and validation of expectations about a model as we demonstrate later.

[@cr-desrun1]{highlight="13-14"} We add in cost and health outcomes.

:::{#cr-desrun1}
```{r}
#| echo: true
#| code-line-numbers: true
des_run <- function(inputs)
{
  env  <<- simmer("SickSicker")
  traj <- des(env, inputs)
  env |> 
    create_counters(counters) |>
    add_generator("patient", traj, at(rep(0, inputs$N)), mon=2) |>
    # Simulate just past horizon (in years)
    run(inputs$horizon+1/365) |> 
    wrap()
        
  get_mon_arrivals(env, per_resource = T) |>
    cost_arrivals(inputs) |> 
    qaly_arrivals(inputs) 
}


```
:::

:::


# Model 2: A Simple Mortality Model

Our first addition to the simple model will be to add background mortality. 

:::{.cr-section layout="overlay-center"}

@cr-petri2

We have added the possibility of death as an event that can occur before the patient reaches the end of the time horizon  ... [@cr-petri2]{pan-to="35%,50%" scale-by="1.5"}

@cr-petri2


:::{#cr-petri2}
![](images/petri-model2.png){fig-align="center"}

:::

:::

Our next objective is to add an event---death---to the model.

1. Add event to counter
2. Define function for time till event
3. Define function to mark and update the patient trajectory
4. Add event to event registry

:::{.cr-section}
Add death to the counter @cr-counter2

:::{#cr-counter2}
```{r}
#| echo: true
#| code-line-numbers: true
  
  counters <- c(
    "time_in_model",
    "death"
  )
```
:::

Next we define a function to sample time till event @cr-yearstodeath

:::{#cr-yearstodeath}
```{r}
#| echo: true
#| code-line-numbers: true

years_till_death <- function(inputs)
{
  rexp(1, inputs$r.HD)
}
```

:::

@cr-deathevent

Net we define a function to mark and update the patient registry. 

:::{#cr-deathevent}
```{r}
#| echo: true
#| code-line-numbers: true

death <- function(traj, inputs)
{
  traj |> branch(
    function() 1,
    continue=c(FALSE), # False is patient death, had to use a branch to force termination
    trajectory("Death") |>
      mark("death")     |> # Must be in 'counters'
      terminate_simulation()
  )
}
```

:::

 @cr-registry2

Finally, we add the event to the event registry. [ @cr-registry2]{highlight="7-11"}

:::{#cr-registry2}
```{r}
#| echo: true
#| code-line-numbers: true

event_registry <- list(
  list(name          = "Terminate at time horizon",
       attr          = "aTerminate",
       time_to_event = function(inputs) inputs$horizon,
       func          = terminate_simulation,
       reactive      = FALSE),
  list(name          = "Death",
       attr          = "aDeath",
       time_to_event = years_till_death,
       func          = death,
       reactive      = TRUE)
)
```

:::

:::

Let's run the model and look at the output. 

```{r}
#| echo: true
#| eval: false

des_run(inputs)
```

:::{.cr-section layout="overlay-center"}

:::{#cr-res2_1}

```{r}
#| echo: false
library(kableExtra)
set.seed(23)
df <- des_run(inputs)
df %>%
  kbl() %>%
  kable_styling() 
```
:::

:::{#cr-res2_2}

```{r}
#| echo: false
df %>%
  kbl() %>%
  kable_styling() %>%
  row_spec(c(1), background = "#fff3cd") 

```
:::

:::{#cr-res2_3}

```{r}
#| echo: false
df %>%
  kbl() %>%
  kable_styling() %>%
  row_spec(c(2), background = "#fff3cd") 

```
:::

@cr-res2_1

@cr-res2_2 Notice how this patient dies before the 30-year time horizon. The `resource` column
indicates that the death event occurred for this patient, and the `start_time` column indicates the time at which the event occurred (`r round(df$start_time[1],2)` years). 

@cr-res2_3 In total, and as a result of early death, this patient contributed `r round(df$dqaly[2],2)` discounted QALYs to the simulated population. 


:::


# Model 3: Adding in a Sick State

Our next addition is to add disease incidence to the model. 

:::{.cr-section layout="overlay-center"}

@cr-petri3

We have added the possibility of transitions to a diseased state ("S") a  ... [@cr-petri3]{pan-to="35%,30%" scale-by="1.5"}

@cr-petri3


:::{#cr-petri3}
![](images/petri-model3.png){fig-align="center"}

:::
:::




:::{.cr-section}

Need a lookup table for numeric mapping to health states. @cr-statelut

:::{#cr-statelut}
```{r}
#| echo: true
#| code-line-numbers: true

state_lut <- c(
  "0" = "H",
  "1" = "S1",
  "2" = "S2"
)

```

:::


Update counters @cr-counters3

:::{#cr-counters3}

```{r}
#| echo: true
#| code-line-numbers: true

counters <- c(
  "time_in_model",
  "death",
  "healthy",
  "sick1"
)
```

:::

Need to define functions for the event of getting sick @cr-sick3

:::{#cr-sick3}

```{r}
#| echo: true
#| code-line-numbers: true

years_till_sick1 <- function(inputs)
{
  state <- get_attribute(env, "State") 
  if(state == 0) # 0 => Healthy
  {
    rexp(1,inputs$r.HS1)
  } else
  {
    inputs$horizon+1 # Past end of simulation time
  }
}

sick1 <- function(traj, inputs)
{
  traj                      |> 
  set_attribute("State", 1) |> # 1 => Sick 1 (S1)
  release('healthy')        |> # Track state change for tally later
  seize('sick1')
}
```

:::


Also need to update death event to account for higher risk of death @cr-death3

:::{#cr-death3}

```{r}
#| echo: true
#| code-line-numbers: true

years_till_death <- function(inputs)
{
  state <- get_attribute(env, "State")
  rate <- inputs$r.HD
  if(state == 1) rate <- rate * inputs$hr.S1D # Deal with Sick1 Hazard Ratio
  rexp(1, rate)
}
```

:::

And update QoL and Costs to account for costs and utility weight while sick @cr-outcomes3_1

Then @cr-outcomes3_2

:::{#cr-outcomes3_1}

```{r}
#| echo: true
#| code-line-numbers: true

cost_arrivals <- function(arrivals, inputs)
{
  arrivals$cost  <- 0  # No costs yet
  arrivals$dcost <- 0  # No discounted costs either
  
  selector = arrivals$resource == 'healthy'
  arrivals$cost[selector] <- inputs$c.H *
    (arrivals$end_time[selector] - arrivals$start_time[selector])
  arrivals$dcost[selector] <- discount_value(inputs$c.H,
    arrivals$start_time[selector], arrivals$end_time[selector])
  
  selector = arrivals$resource == 'sick1'
  arrivals$cost[selector] <- inputs$c.S1 *
    (arrivals$end_time[selector] - arrivals$start_time[selector])
  arrivals$dcost[selector] <- discount_value(inputs$c.S1,
    arrivals$start_time[selector], arrivals$end_time[selector])
 
  arrivals
}

```
:::


:::{#cr-outcomes3_2}

```{r}
#| echo: true
#| code-line-numbers: true

qaly_arrivals <- function(arrivals, inputs)
{
  arrivals$qaly  <- 0  # No qaly yet
  arrivals$dqaly <- 0  # No discounted qaly either
  
  selector <- arrivals$resource == 'healthy'
  arrivals$qaly[selector] <-
    inputs$u.H*
     (arrivals$end_time[selector] - arrivals$start_time[selector])
  arrivals$dqaly[selector] <- 
      discount_value(inputs$u.H, 
                     arrivals$start_time[selector],
                     arrivals$end_time[selector])
  
  selector <- arrivals$resource == 'sick1'
  arrivals$qaly[selector] <-
    inputs$u.S1*
     (arrivals$end_time[selector] - arrivals$start_time[selector])
  arrivals$dqaly[selector] <- 
      discount_value(inputs$u.S1, 
                     arrivals$start_time[selector],
                     arrivals$end_time[selector])
  
  arrivals
}

```

:::


Now update event registry @cr-registry3

:::{#cr-registry3}
```{r}
#| echo: true
#| code-line-numbers: true

event_registry <- list(
  list(name          = "Terminate at time horizon",
       attr          = "aTerminate",
       time_to_event = function(inputs) inputs$horizon-now(env),
       func          = terminate_simulation,
       reactive      = FALSE),
  list(name          = "Death",
       attr          = "aDeath",
       time_to_event = years_till_death,
       func          = death,
       reactive      = TRUE),
  list(name          = "Sick1",
       attr          = "aSick1",
       time_to_event = years_till_sick1,
       func          = sick1,
       reactive      = TRUE)
)
```
:::

Next we need to modify the initialization of the patient to be healthy. @cr-initialize3

:::{#cr-initialize3}

```{r}
#| echo: true
#| code-line-numbers: true

initialize_patient <- function(traj, inputs)
{
  traj                   |>
  seize("time_in_model") |>
  set_attribute("AgeInitial", function() sample(20:30, 1)) |>
  set_attribute("State", 0) |> # Patients start healthy
  seize("healthy") 
}

```
:::


Need to update cleanup @cr-cleanup3

:::{#cr-cleanup3}

```{r}
#| echo: true
#| code-line-numbers: true

cleanup_on_termination <- function(traj)
{
  traj |> 
  release("time_in_model") |>
  branch( 
    function() get_attribute(env, "State")+1,
      continue = rep(TRUE, 3),
      trajectory() |> release("healthy"),
      trajectory() |> release("sick1"), # Leaving sick1 state on termination
      trajectory()      # Future Sick2 state
  )
}

terminate_simulation <- function(traj, inputs)
{
  traj |>
  branch( function() 1, 
          continue=FALSE,
          trajectory() |> cleanup_on_termination()
        )
}

```

:::

And finally, update the model run code @cr-run3

:::{#cr-run3}

```{r}
#| echo: true
#| code-line-numbers: true

des_run <- function(inputs)
{
  env  <<- simmer("SickSicker")
  traj <- des(env, inputs)
  env |> 
    create_counters(counters) |>
    add_generator("patient", traj, at(rep(0, inputs$N)), mon=2) |>
    run(inputs$horizon+1/365) |> # Simulate just past horizon (in years)
    wrap()
        
  get_mon_arrivals(env, per_resource = T) |>
    cost_arrivals(inputs) |> 
    qaly_arrivals(inputs) 
}

```

:::

:::

```{r}
set.seed(3)
df <- des_run(inputs)
df %>%
  kbl() %>%
  kable_styling() 
```

# Model 4: Add Recovery


Our next addition is to add disease recovery to the model. 

:::{.cr-section layout="overlay-center"}

@cr-petri4

We have added the possibility of recovery ... [@cr-petri4]{pan-to="35%,30%" scale-by="1.5"}

@cr-petri4


:::{#cr-petri4}
![](images/petri-model4.png){fig-align="center"}

:::
:::


# Model 5: Add Recovery


Our next addition is to add disease progression to the model. 

:::{.cr-section layout="overlay-center"}

@cr-petri5

We have added the possibility of disease progression  ... [@cr-petri5]{pan-to="35%,30%" scale-by="1.5"}

@cr-petri5


:::{#cr-petri5}
![](images/petri-model4.png){fig-align="center"}

:::
:::



