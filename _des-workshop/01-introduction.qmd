---
title: "1. Overview of Discrete Event Simulation"
subtitle: "Discrete Event Simulation for Health Decision Modeling"
author: 
  - name: "John Graves"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt Owen Gradute School of Management"
      - "Vanderbilt University Medical Center"
    email: "john.graves@vanderbilt.edu"
  - name: "Shawn Garbett"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt University Medical Center"    
    email: "shawn.garbett@vumc.org"
date: today
format: 
  closeread-html:
    css: des-styling.css
    code-tools: false
    fig-format: svg
    toc: false
    linkcolor: tomato
bibliography: references.bib    
editor_options: 
  chunk_output_type: console
---


# Introduction

::: callout-important
This text was AI-generated just to put in some filler for now; we'll want to go back and edit using our own language. 
:::

<span style="color:cornflowerblue">**Discrete event simulation (DES) **</span> is a modeling framework that offers unique advantages for evaluating complex healthcare interventions and systems. DES explicitly models patient experience in a health care system based on a series of discrete events occurring over time, such as disease onset, treatment initiation, and other clinical outcomes. DES can also capture dynamic interactions between patients and system resources, making it particularly valuable for evaluating interventions that affect system capacity, waiting times, or resource utilization patterns.

## Comparison with Microsimulation

While both DES and microsimulation model individual patients rather than population cohorts, they differ fundamentally in their temporal structure and scope [@graves2021comparison]. Microsimulation follows individuals through predetermined time cycles, updating their characteristics and health states at regular intervals, with a primary focus on long-term disease progression and outcomes. 

DES, in contrast, models the actual sequence and timing of events as they occur, allowing practitioners to explicitly capture healthcare processes, resource constraints, and patient trajectories as they interact in a system (e.g., wait times for a bed or procedure). This makes DES especially suited for modeling the experience of disease---or its absence---while also accounting operational aspects of care delivery that may affect disease severity, progression, and costs. 

## Conceptual Framework

To illustrate these concepts more intuitively, consider a racing metaphor where each patient represents a race car navigating a complex circuit with multiple checkpoints, pit stops, and potential hazards. 

::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 600px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

In this framework, each car follows its own unique journey ("trajectory") through a race course, with discrete events corresponding to key moments like crossing timing markers, making scheduled pit stops for fuel and tire changes, or experiencing unexpected mechanical issues that require roadside assistance. 

The race organizers (i.e., the modeler) track not only each car's total race time but also the precise timing and sequence of every significant event---when cars enter the pit lane, how long they wait for available mechanics, whether they experience delays due to track congestion, and how these operational realities affect both their race performance and resource consumption.

::: {.column-screen style="background-image:url(images/scoreboard-race.png); background-size: 100vw; height: 600px; background-position: center -55%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

This racing analogy highlights the fundamental difference between DES and microsimulation approaches. While microsimulation might update each car's position and characteristics at regular time intervals - checking their status every five minutes regardless of what's happening on the track - DES models the actual sequence of racing events as they unfold in real-time. It captures the moment a car crosses the start line, navigates a challenging turn, requires emergency pit service, or encounters a yellow flag that affects the entire field. Just as race organizers need to understand how pit crew availability affects race outcomes, healthcare analysts use DES to model how resource constraints and operational dynamics influence patient experiences and clinical outcomes.

::: {.column-screen style="background-image:url(images/finish-line-cars.png); background-size: 100vw; height: 400px; background-position: center +15%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>


The competitive dynamics inherent in racing perfectly mirror the resource competition found in healthcare systems. When multiple cars need pit service simultaneously, queues form and strategic decisions must be made about service priority - much like patients competing for limited hospital beds, surgical slots, or specialist appointments. DES excels at modeling these interactions, capturing how a crash requiring track cleanup affects all subsequent cars, how limited pit crews create bottlenecks during busy periods, and how the timing of these events influences both individual race outcomes and overall resource utilization. However, this detailed operational focus comes with increased complexity in model development and validation, requiring precise information about pit stop procedures, crew availability, and track conditions that might not be readily available. While DES proves invaluable when interventions directly affect the racing infrastructure and competitive dynamics, microsimulation remains more practical for analyzing long-term driver career outcomes where the operational details of individual races are less critical to the overall assessment.

# Setup

Our first task is to prepare our R session for the simulation. 

We begin by loading necessary libraries.

:::{.cr-section}
Simmer is the most important [@cr-libraries]{highlight="1"}

:::{#cr-libraries}
```{r setup}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true

library(simmer)
library(here)
```

:::
:::

# Model Inputs

We next define model inputs. 

:::{.cr-section}

Model inputs are shown here @cr-inputs @cr-inputs


:::{#cr-inputs}
```{r}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true
#| 
inputs <- list(
    N      = 5,
  
    # Parameters
    horizon=    30,      # Time horizon
    
    # Cycle => 1 year
    d.r    =     0.03,   # Discount Rate
    
    r.HS1  =     0.15,   # Disease Onset Rate / year       (H  -> S1)
    r.S1H  =     0.7,    # Recovery Rate / year            (S1 -> H)
    r.S1S2 =     0.10,   # Disease Progression rate / year (S1 -> S2)
    r.HD   =     0.005,  # Healthy to Dead rate / year     (H  -> D)
    hr.S1D =     3,      # Hazard ratio in S1 vs healthy 
    hr.S2D =    10,      # Hazard ratio in S2 vs healthy
 
    # Annual Costs
    c.H    =  2000,      # Healthy individuals 
    c.S1   =  4000,      # Sick individuals in S1
    c.S2   = 15000,      # Sick individuals in S2
    c.D    =     0,      # Dead individuals
    c.Trt  = 12000,      # Additional Annual cost for S1 and S2
    
    # Utility Weights
    u.H    =     1.00,   # Healthy
    u.S1   =     0.80,   # S1
    u.S2   =     0.60,   # S2
    u.D    =     0.00,   # Dead
    
    # Intervention Effect
    u.Trt  =     0.95,   # S1 Utility for treatment in S1
    
    wtp    =     1e5,    # 100k willingness to pay
    
    strategy = 'notreat' # Default strategy is no treatment
  )

```
:::

:::

:::{.cr-section}

All inputs are summarized in a standalone script `inputs.R`. [@cr-boilerplate]{highlight="1"}

`main_loop.R` contains some helper functions. [@cr-boilerplate]{highlight="2"}

A small diversion is we need to be able to apply [discounting](https://en.wikipedia.org/wiki/Discounting) to our results. Thus a numerically stable and vectorized version of discounting is just the ticket. [@cr-boilerplate]{highlight="3"} The file [`discount.R`](./discount.R) contains what's required. Other common versions utilize the power definition of discounting, this uses the "\^" operator which limits the numerical stable range of the function. Our function uses the exponential formulation with a greater numerical stability. The function also does point discounting or integrated area discounted.

:::{#cr-boilerplate}
```{r}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true
source(here('inputs.R'))     # Model Parameters
source(here('main_loop.R'))  # Helper functions
source(here('discount.R'))   # Discounting functions
```

:::
:::

# Petri Net Diagrams

A <span style="color:#007bdd">**Petri Net diagram**</span> is a graphical modeling tool that represents the flow of resources, entities, and control through a DES over time. It's particularly useful for modeling concurrent processes and shared resources.  

![](images/petri-model5.png){fig-align="center"}
Petri nets offer a **graphical grammar** that aligns neatly with discrete-event
simulation (DES):

| Element | Symbol | In our disease model… |
|---------|--------|-----------------------|
| *Place* | ● (circle) | Clinical states (`H`, `S1`, `S2`), queues, resources |
| *Token* | ⬤ | A single patient or a unit of resource capacity |
| *Transition* | ▭ (bar/rectangle) | Events: incidence, progression, death, censoring, resource release |
| *Arc* | → | Preconditions & results of an event |
| *Marking* | Distribution of tokens | Current cohort composition and resource utilisation |

<div class="callout-tip">
A transition **fires** only when every input place supplies at least one token —  
perfect for competing-risk logic in progressive disease.
</div>

---
title: "Petri-Net Diagrams for Progressive Disease Models"
author: "Your Name"
format:
  html: default
  pdf: default
editor: source   # keep raw; don’t knit on load
---

## 1  Why Petri Nets for Health-Economic DES?

Petri nets offer a **graphical grammar** that aligns neatly with discrete-event
simulation (DES):

| Element | Symbol | In our disease model… |
|---------|--------|-----------------------|
| *Place* | ● (circle) | Clinical states (`H`, `S1`, `S2`), queues, resources |
| *Token* | ⬤ | A single patient or a unit of resource capacity |
| *Transition* | ▭ (bar/rectangle) | Events: incidence, progression, death, censoring, resource release |
| *Arc* | → | Preconditions & results of an event |
| *Marking* | Distribution of tokens | Current cohort composition and resource utilisation |

<div class="callout-tip">
A transition **fires** only when every input place supplies at least one token —  
perfect for competing-risk logic in progressive disease.
</div>

---

## 2  Core Progressive-Disease Net

Below is DOT code you can render via the **dot** engine (Graphviz).  
Tokens start in `H` at _t = 0_.

```{dot}
digraph DiseaseNet {
  rankdir=LR;
  labelloc=t;
  label="Progressive disease • follow until T or death";

  node [shape=circle, fontsize=10, fixedsize=false, width=1.1];
  H   [label="H\n(Healthy)"];
  S1  [label="S1\n(Disease)"];
  S2  [label="S2\n(Progressed)"];
  Dsec[shape=doublecircle, label="D_sec\n(Secular)"];
  Ddis[shape=doublecircle, label="D_dis\n(Disease)"];
  Tend[shape=doublecircle, label="T_end\n(Admin censor)"];

  node [shape=box, height=0.3, width=0.5, fontsize=9];
  tInc[label="Incidence"];
  tProg[label="Progression"];
  tRec [label="Recovery"];
  tD1 [label="Death"];
  tD2 [label="Death"];
  tD0 [label="Death"];
  tC0 [label="Censor"];
  tC1 [label="Censor"];
  tC2 [label="Censor"];

  H  -> tInc -> S1;
  H  -> tD0  -> Dsec;
  H  -> tC0  -> Tend;

  S1 -> tProg -> S2;
  S1 -> tRec  -> H;
  S1 -> tD1   -> Ddis;
  S1 -> tC1   -> Tend;

  S2 -> tD2   -> Ddis;
  S2 -> tC2   -> Tend;
}

```

```{dot}
digraph QueueNet {
  rankdir=LR; nodesep=0.35;

  node [shape=circle, fontsize=10];
  Q   [label="Q_wait"];
  R   [label="R_cap\n(init = 1)"];
  Svc [label="InService"];

  node [shape=box, fontsize=9, height=0.3, width=0.5];
  Arrive  [label="Arrival"];
  Seize   [label="Seize"];
  Release [label="Release"];

  /* arcs */
  Arrive -> Q;
  Q -> Seize;          R -> Seize;
  Seize -> Svc;
  Svc -> Release;
  Release -> R;
  Release -> P_done [shape=circle,label="Next\nstate"];
}
```

# Extra Stuff

<span class="hl hl-blue">blue highlighted text</span> 
<span class="hl hl-red">red highlighted text</span> 
<span class="hl hl-cyan">cyan highlighted text</span> 
<span class="hl hl-green">green highlighted text</span> 
<span class="hl hl-brown">brown highlighted text</span> 

Here's some <span style="color:cornflowerblue">**some bolded blue text**</span>
How about some <span style="color:firebrick">**red bolded text**</span>
How about some <span style="color:darkcyan">**cyan bolded text**</span> 



