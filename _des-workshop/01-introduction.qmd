---
title: "Discrete Event Simulation for Health Decision Modeling"
subtitle: "1. Introduction"
author: 
  - name: "John Graves"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt Owen Gradute School of Management"
      - "Vanderbilt University Medical Center"
    email: "john.graves@vanderbilt.edu"
  - name: "Shawn Garbett"
    affiliation: 
      - "Vanderbilt University School of Medicine"
      - "Vanderbilt University Medical Center"    
    email: "shawn.garbett@vumc.org"
date: today
format: 
  closeread-html:
    css: des-styling.css
    code-tools: false
    fig-format: svg
    toc: false
    linkcolor: tomato
bibliography: references.bib    
editor_options: 
  chunk_output_type: console
---


# Introduction

::: callout-important
This text was AI-generated just to put in some filler for now; we'll want to go back and edit using our own language. 
:::

<span style="color:cornflowerblue">**Discrete event simulation (DES) **</span> is a modeling framework that offers unique advantages for evaluating complex healthcare interventions and systems. DES explicitly models patient experience in a health care system based on a series of discrete events occurring over time, such as disease onset, treatment initiation, and other clinical outcomes. DES can also capture dynamic interactions between patients and system resources, making it particularly valuable for evaluating interventions that affect system capacity, waiting times, or resource utilization patterns.

## Comparison with Microsimulation

While both DES and microsimulation model individual patients rather than population cohorts, they differ fundamentally in their temporal structure and scope [@graves2021comparison]. Microsimulation follows individuals through predetermined time cycles, updating their characteristics and health states at regular intervals, with a primary focus on long-term disease progression and outcomes. 

DES, in contrast, models the actual sequence and timing of events as they occur, allowing practitioners to explicitly capture healthcare processes, resource constraints, and patient trajectories as they interact in a system (e.g., wait times for a bed or procedure). This makes DES especially suited for modeling the experience of disease---or its absence---while also accounting operational aspects of care delivery that may affect disease severity, progression, and costs. 

## Conceptual Framework

To illustrate these concepts more intuitively, consider a racing metaphor where each patient represents a race car navigating a complex circuit with multiple checkpoints, pit stops, and potential hazards. 

::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 600px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

In this framework, each car follows its own unique journey ("trajectory") through a race course, with discrete events corresponding to key moments like crossing timing markers, making scheduled pit stops for fuel and tire changes, or experiencing unexpected mechanical issues that require roadside assistance. 

The race organizers (i.e., the modeler) track not only each car's total race time but also the precise timing and sequence of every significant event---when cars enter the pit lane, how long they wait for available mechanics, whether they experience delays due to track congestion, and how these operational realities affect both their race performance and resource consumption.

::: {.column-screen style="background-image:url(images/scoreboard-race.png); background-size: 100vw; height: 600px; background-position: center -55%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

This racing analogy highlights the fundamental difference between DES and microsimulation approaches. While microsimulation might update each car's position and characteristics at regular time intervals - checking their status every five minutes regardless of what's happening on the track - DES models the actual sequence of racing events as they unfold in real-time. It captures the moment a car crosses the start line, navigates a challenging turn, requires emergency pit service, or encounters a yellow flag that affects the entire field. Just as race organizers need to understand how pit crew availability affects race outcomes, healthcare analysts use DES to model how resource constraints and operational dynamics influence patient experiences and clinical outcomes.

::: {.column-screen style="background-image:url(images/finish-line-cars.png); background-size: 100vw; height: 400px; background-position: center +15%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>


The competitive dynamics inherent in racing perfectly mirror the resource competition found in healthcare systems. When multiple cars need pit service simultaneously, queues form and strategic decisions must be made about service priority - much like patients competing for limited hospital beds, surgical slots, or specialist appointments. DES excels at modeling these interactions, capturing how a crash requiring track cleanup affects all subsequent cars, how limited pit crews create bottlenecks during busy periods, and how the timing of these events influences both individual race outcomes and overall resource utilization. However, this detailed operational focus comes with increased complexity in model development and validation, requiring precise information about pit stop procedures, crew availability, and track conditions that might not be readily available. While DES proves invaluable when interventions directly affect the racing infrastructure and competitive dynamics, microsimulation remains more practical for analyzing long-term driver career outcomes where the operational details of individual races are less critical to the overall assessment.

# Setup

Our first task is to prepare our R session for the simulation. 

We begin by loading necessary libraries.

:::{.cr-section}
Simmer is the most important [@cr-libraries]{highlight="1"}

:::{#cr-libraries}
```{r setup}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true

library(simmer)
library(here)
```

:::
:::

# Model Inputs

We next define model inputs. 

:::{.cr-section}

Model inputs are shown here @cr-inputs @cr-inputs


:::{#cr-inputs}
```{r}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true
#| 
inputs <- list(
    N      = 5,
  
    # Parameters
    horizon=    30,      # Time horizon
    
    # Cycle => 1 year
    d.r    =     0.03,   # Discount Rate
    
    r.HS1  =     0.15,   # Disease Onset Rate / year       (H  -> S1)
    r.S1H  =     0.7,    # Recovery Rate / year            (S1 -> H)
    r.S1S2 =     0.10,   # Disease Progression rate / year (S1 -> S2)
    r.HD   =     0.005,  # Healthy to Dead rate / year     (H  -> D)
    hr.S1D =     3,      # Hazard ratio in S1 vs healthy 
    hr.S2D =    10,      # Hazard ratio in S2 vs healthy
 
    # Annual Costs
    c.H    =  2000,      # Healthy individuals 
    c.S1   =  4000,      # Sick individuals in S1
    c.S2   = 15000,      # Sick individuals in S2
    c.D    =     0,      # Dead individuals
    c.Trt  = 12000,      # Additional Annual cost for S1 and S2
    
    # Utility Weights
    u.H    =     1.00,   # Healthy
    u.S1   =     0.80,   # S1
    u.S2   =     0.60,   # S2
    u.D    =     0.00,   # Dead
    
    # Intervention Effect
    u.Trt  =     0.95,   # S1 Utility for treatment in S1
    
    wtp    =     1e5,    # 100k willingness to pay
    
    strategy = 'notreat' # Default strategy is no treatment
  )

```
:::

:::

:::{.cr-section}

All inputs are summarized in a standalone script `inputs.R`. [@cr-boilerplate]{highlight="1"}

`main_loop.R` contains some helper functions. [@cr-boilerplate]{highlight="2"}

A small diversion is we need to be able to apply [discounting](https://en.wikipedia.org/wiki/Discounting) to our results. Thus a numerically stable and vectorized version of discounting is just the ticket. [@cr-boilerplate]{highlight="3"} The file [`discount.R`](./discount.R) contains what's required. Other common versions utilize the power definition of discounting, this uses the "\^" operator which limits the numerical stable range of the function. Our function uses the exponential formulation with a greater numerical stability. The function also does point discounting or integrated area discounted.

:::{#cr-boilerplate}
```{r}
#| echo: true
#| warning: false
#| message: false
#| code-line-numbers: true
source(here('inputs.R'))     # Model Parameters
source(here('main_loop.R'))  # Helper functions
source(here('discount.R'))   # Discounting functions
```

:::
:::

# Model 1


:::{.cr-section layout="overlay-center"}

A <span style="color:#007bdd">**Petri Net diagram**</span> is a graphical modeling tool that represents the flow of resources, entities, and control through a DES over time. It's particularly useful for modeling concurrent processes and shared resources.  @cr-petri1. 

For our first (very simple!) DES we will model a system that initiates ... [@cr-petri1]{pan-to="50%,-90%" scale-by="2"}

... and then follows patients for a defined 30-year time horizon. 
[@cr-petri1]{pan-to="-50%,-50%" scale-by="2"} 

@cr-petri1

Later, we will build up this very simple DES by incorporating additional components such as health state transitions, background mortality, and resource queues. 

:::{#cr-petri1}
![](images/petri-model1.png){fig-align="center"}
:::

:::


## Counters

::: {.column-screen style="background-image:url(images/scoreboard-race.png); background-size: 100vw; height: 600px; background-position: center -55%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>



Think of a counter like a scoreboard that lists race times, including times for each lap (event) in the race. For our simple model, our counter will operate exactly like this---it will simply track the amount of time each patient spends in the model. 



:::{.cr-section}

Counters are defined as a vector object that provides the names of each event we want to track in the model. This vector will be used later with a convenience function we have written for `Simmer` ( `main_loop()`) to define resources with infinite capacity, i.e., there is no competition for a resource like "time in model"). @cr-counters0

For this very simple model, we will simply track patients for a defined time horizon of 30 years.  Thus, our first `counter` will be `time_in_model`. @cr-counters

:::{#cr-counters0}
```{r}
#| echo: true
#| eval: false
#| code-line-numbers: false

counters <- c(
  #<names of counters go here>
)
```
:::

:::{#cr-counters}
```{r}
#| echo: true
#| code-line-numbers: false

counters <- c(
  "time_in_model"
)
```

:::
:::


## Initializing Patients

We next need to define a process that will initialize patients in the model. Extending the racing analogy further, think of this process in terms of defining the pole positions of each "car" in the race: we want to define baseline attributes, like:

- Age
- Disease status (e.g., healthy, ill)
- Gender


::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 500px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>


:::{.cr-section layout="overlay-center"}

The pipe operator |> in R is a tool for chaining operations together in a left-to-right, readable sequence. Instead of nesting functions or creating intermediate variables, you "pipe" the output of one function directly into the next function as its first argument.

:::

:::{.cr-section layout="sidebar-right"}
For example, this syntax using pipe operators ... 
@cr-pipesyntax

:::{#cr-pipesyntax}
```{r}
#| echo: true
#| eval: false

data |> function1() |> function2() |> function3()
```
:::
:::


:::{.cr-section layout="sidebar-right"}

@cr-pipesyntax2  
... is equivalent to:
@cr-pipesyntax2

:::{#cr-pipesyntax2}
```{r}
#| echo: true
#| eval: false

function3(function2(function1(data)))
```

:::
:::

Let's now define a function `initialize_patient()` to define the starting state of a patient. This can be as complex as needed to define the attributes of the starting population of a study.

::: {.column-screen style="background-image:url(images/starting-line-cars2.png); background-size: 100vw; height: 500px; background-position: center bottom; background-repeat: no-repeat; opacity: 0.25"}
:::



:::{.cr-section }
Our function has two inputs: `traj` and `inputs`. [@cr-initialize]{highlight="1"}  The object `inputs` are the parameters that define our model, and were defined above (and are also stored in `inputs.R`). 

A trajectory (`traj`) is a sequence of events that defines what happens to people as they move through the DES. You can think of `traj` in terms of a personalized race course for each person in the model. 

In our code here, for a given patient we start with its trajectory [@cr-initialize]{highlight="3"}

We then feed this trajectory into the simmer function `seize()`. [@cr-initialize]{highlight="4"} This function siezes the counter `time_in_model`  that we defined above. You can think of this step in terms of taking our patient and directing them to the starting line of the simulation.   

The `initialize_patient()` function is also our opportunity to set baseline attributes of our patients. For example, here we sample the patient's age in years from a uniform distribution between age 20 and 30. [@cr-initialize]{highlight="5"} This attribute isn't actually going to be used for now; we include it here simply to demonstrate how baseline attributes can be set. You can define as many of these attributes as needed to execute the model. 


@cr-initialize


:::{#cr-initialize}
```{r}
#| echo: true
#| code-line-numbers: true
initialize_patient <- function(traj, inputs)
{
  traj                   |>
  seize("time_in_model") |>
  set_attribute("AgeInitial", function() sample(20:30, 1))
}
```
:::


:::

:::{.cr-section layout="overlay-center"}
**NOTE**: It is important when using simmer to mostly pass functions for defining things in a trajectory. This is a call back, and if not done properly it can result in puzzling behavior. If one passed to simmer the following: `sample(20:30,1)`, it would result in a single random draw applied to every single patient. For example, if 25 were draw every patient would be 25. Instead one needs to pass to simmer `function() sample(20:30,1)` to get a random draw for each patient resulting a uniform spread of this parameter. If every patient had the same attribute being assigned, it would be fine to leave off the `function()`, but this can lead to forgetting to do it in cases where it's needed and it doesn't hurt to leave it in on all calls. @cr-initialize
:::


## Define the Finish Line

The steps above were used to define the starting line and to define the dimensions we want to track and measure. The last step is to define where the model should end. That is, how do we define the "end" of the patient's trajectory through the system? Once we define this end, we need to "release" the various counters (e.g., time in model) and resources we've defined. 

We'll do this using a series of "cleanup" functions that release the patient at the end of their journey through the model. 

::: {.column-screen style="background-image:url(images/finish-line-cars.png); background-size: 100vw; height: 300px; background-position: center 35%; background-repeat: no-repeat; opacity: 0.5"}
:::
<figcaption>Image generated by ChatGPT 4o</figcaption>

:::{.cr-section}

When a patient leaves the simulation via any means it is helpful to have a function that examines the state or attributes of that patient/trajectory and releases any resources they used. @cr-cleanup

[@cr-cleanup]{highlight="1-5"} In this section, we know they've seized `time_in_model`, so they need to let that go when they exit.

This function can get a lot more complex as patient state grows more complex.


[@cr-cleanup]{highlight="7-14"} This routine terminates the trajectory and calls the above cleanup. These two pieces could easily have been one function, but keeping them separate has proven useful in practice, primarily for organizational purposes.


:::{#cr-cleanup}
```{r}
#| echo: true
#| code-line-numbers: true

cleanup_on_termination <- function(traj)
{
  traj |> 
  release("time_in_model")
}

terminate_simulation <- function(traj, inputs)
{
  traj |>
  branch( function() 1, 
          continue=FALSE,
          trajectory() |> cleanup_on_termination()
        )
}

```

:::
:::

## Event Registry

Now we're approaching the heart of the model. The event registry. We're going to define a single event to terminate the patient trajectory when the defined time horizon is reached. For a full life simulation such a function isn't needed as a proper mortality model would have individuals simulated die at some point, however it's not bad to have something like this to prevent a run away simulation.


:::{.cr-section}

Here's how it looks for a single entry. @cr-registry

:::{#cr-registry}
```{r}
#| echo: true
#| code-line-numbers: true

event_registry <- list(
  list(name          = "Terminate at time horizon",
       attr          = "aTerminate",
       time_to_event = function(inputs) inputs$horizon,
       func          = terminate_simulation,
       reactive      = FALSE)
)
```
:::

[@cr-registry]{highlight="2"} The `name` field is for debugging purposes and may come up on a simmer trace. It's not used much in practice. 

[@cr-registry]{highlight="3"} `attr` is the name of the attribute on a patient used to store the time to event. It needs to be unique and not correspond to any other attribute name defined on the patient. 

[@cr-registry]{highlight="4"} `time_to_event` is a callback function that defines how long till the event occurs. Simulation time starts at 0 and proceeds forward. 

[@cr-registry]{highlight="4"}  In this model we have chosen the cycle to each a year. Thus when time reaches 2.0, that's 2 years into the simulation for that patient---*not their age*. 

[@cr-registry]{highlight="5"} The `func` is the callback function that will modify the state of the patient, in this case it's the terminate simulation function defined above.

[@cr-registry]{highlight="6"}  The `reactive` field is a logical TRUE/FALSE that defines whether all other events should be redraw if this event fires. In this case the patient trajectory is ending, so no events for them should be redrawn.

:::

## Tracking Outcomes 

### Quality of Life (QoL)

:::{.cr-section }

@cr-QoL

:::{#cr-QoL}

```{r}
#| echo: true
#| code-line-numbers: true

qaly_arrivals <- function(arrivals, inputs)
{
  arrivals$qaly  <- 0  # No qaly yet
  arrivals$dqaly <- 0  # No discounted qaly either
  
  selector <- arrivals$resource == 'time_in_model'
  arrivals$qaly[selector] <-
    arrivals$end_time[selector] - 
    arrivals$start_time[selector]
  arrivals$dqaly[selector] <- 
      discount_value(1, 
                     arrivals$start_time[selector],
                     arrivals$end_time[selector])
    
  arrivals
}

```
:::
:::



### Costs

We need to define incured costs for our model. It should take the data.frame from `des_run` and add cost columns for the resources. We pass in the inputs as they might be needed. We will ignore the costs for healthy till we can add that state later.

:::{.cr-section}

@cr-costs

:::{#cr-costs}

```{r}
#| echo: true
#| code-line-numbers: true
cost_arrivals <- function(arrivals, inputs)
{
  arrivals$cost  <- 0  # No costs yet
  arrivals$dcost <- 0  # No discounted costs either
  
  arrivals
}
```

:::
:::




:::{.cr-section}

The function `des_run` is the primary simulation function. @cr-desrun1

[@cr-desrun1]{highlight="3"} The first step is to create a global environment used to run simmer. This is followed by creating a des definition of a trajectory (this function is in `main_loop`. It uses the things we've defined above.

[@cr-desrun1]{highlight="4"}  The patient trajectory (`traj`) is defined by our helper function `des()`, which can be found in `main_loop.R`. It essentially creates a patient, assigns attributes and events, and processes the events. Think of this function as the one that runs a single car through the race course. 

[@cr-desrun1]{highlight="5-10"}   `env` is given resources or counters, patients are generated into the simulation, the simulation is run for an amount of time (just past the horizon) and then the `wrap` makes sure all summaries are ready.

[@cr-desrun1]{highlight="12"} `get_mon_arrival` returns us the trajectories of the patients in a `data.frame`. We will expand on this quite a bit later. It really the soul of understanding what's going on in a simulation and critical for auditing and validation of expectations about a model as we demonstrate later.

[@cr-desrun1]{highlight="13-14"} We add in cost and health outcomes.

:::{#cr-desrun1}
```{r}
#| echo: true
#| code-line-numbers: true
des_run <- function(inputs)
{
  env  <<- simmer("SickSicker")
  traj <- des(env, inputs)
  env |> 
    create_counters(counters) |>
    add_generator("patient", traj, at(rep(0, inputs$N)), mon=2) |>
    # Simulate just past horizon (in years)
    run(inputs$horizon+1/365) |> 
    wrap()
        
  get_mon_arrivals(env, per_resource = T) |>
    cost_arrivals(inputs) |> 
    qaly_arrivals(inputs) 
}


```
:::

:::


# Model 2: A Simple Mortality Model

Our first addition to the simple model will be to add background mortality. 

:::{.cr-section layout="overlay-center"}

@cr-petri2

We have added the possibility of death as an event that can occur before the patient reaches the end of the time horizon  ... [@cr-petri2]{pan-to="-25%,0%" scale-by="1.5"}

@cr-petri2


:::{#cr-petri2}
![](images/petri-model2.png){fig-align="center"}

:::

:::

Our next objective is to add an event---death---to the model.

1. Add event to counter
2. Define function for time till event
3. Define function to mark and update the patient trajectory
4. Add event to event registry

:::{.cr-section}
Add death to the counter @cr-counter2

:::{#cr-counter2}
```{r}
#| echo: true
#| code-line-numbers: true
  
  counters <- c(
    "time_in_model",
    "death"
  )
```
:::

Next we define a function to sample time till event @cr-yearstodeath

:::{#cr-yearstodeath}
```{r}
#| echo: true
#| code-line-numbers: true

years_till_death <- function(inputs)
{
  rexp(1, inputs$r.HD)
}
```

:::

@cr-deathevent

Net we define a function to mark and update the patient registry. 

:::{#cr-deathevent}
```{r}
#| echo: true
#| code-line-numbers: true

death <- function(traj, inputs)
{
  traj |> branch(
    function() 1,
    continue=c(FALSE), # False is patient death, had to use a branch to force termination
    trajectory("Death") |>
      mark("death")     |> # Must be in 'counters'
      terminate_simulation()
  )
}
```

:::

 @cr-registry2

Finally, we add the event to the event registry. [ @cr-registry2]{highlight="7-11"}

:::{#cr-registry2}
```{r}
#| echo: true
#| code-line-numbers: true

event_registry <- list(
  list(name          = "Terminate at time horizon",
       attr          = "aTerminate",
       time_to_event = function(inputs) inputs$horizon,
       func          = terminate_simulation,
       reactive      = FALSE),
  list(name          = "Death",
       attr          = "aDeath",
       time_to_event = years_till_death,
       func          = death,
       reactive      = TRUE)
)
```

:::

:::

Let's run the model and look at the output. 

```{r}
#| echo: true
#| eval: false

des_run(inputs)
```

:::{.cr-section layout="overlay-center"}

:::{#cr-res2_1}

```{r}
#| echo: false
library(kableExtra)
set.seed(23)
df <- des_run(inputs)
df %>%
  kbl() %>%
  kable_styling() 
```
:::

:::{#cr-res2_2}

```{r}
#| echo: false
df %>%
  kbl() %>%
  kable_styling() %>%
  row_spec(c(1), background = "#fff3cd") 

```
:::

:::{#cr-res2_3}

```{r}
#| echo: false
df %>%
  kbl() %>%
  kable_styling() %>%
  row_spec(c(2), background = "#fff3cd") 

```
:::

@cr-res2_1

@cr-res2_2 Notice how this patient dies before the 30-year time horizon. The `resource` column
indicates that the death event occurred for this patient, and the `start_time` column indicates the time at which the event occurred (`r round(df$start_time[1],2)` years). 

@cr-res2_3 In total, and as a result of early death, this patient contributed `r round(df$dqaly[2],2)` discounted QALYs to the simulated population. 


:::



# Extra Stuff

<span class="hl hl-blue">blue highlighted text</span> 
<span class="hl hl-red">red highlighted text</span> 
<span class="hl hl-cyan">cyan highlighted text</span> 
<span class="hl hl-green">green highlighted text</span> 
<span class="hl hl-brown">brown highlighted text</span> 

Here's some <span style="color:cornflowerblue">**some bolded blue text**</span>
How about some <span style="color:firebrick">**red bolded text**</span>
How about some <span style="color:darkcyan">**cyan bolded text**</span> 


